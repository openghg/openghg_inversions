from __future__ import annotations

from abc import ABC, abstractmethod
import inspect
from typing import Any, Iterable, Protocol, TypeVar, runtime_checkable

import numpy as np
import pandas as pd
import pymc as pm
import pytensor.tensor as pt
from pytensor.tensor.variable import TensorVariable
import xarray as xr

from openghg_inversions.models.priors import parse_prior, PriorArgs
from openghg_inversions.models.setup import sigma_freq_indicies


@runtime_checkable
class HasOutput(Protocol):
    @property
    @abstractmethod
    def output(self) -> TensorVariable: ...


@runtime_checkable
class HasCoords(Protocol):
    @abstractmethod
    def coords(self) -> dict: ...


def sum_outputs(components: Iterable[HasOutput]) -> TensorVariable:
    """Sum the output variables of a list of components."""
    return sum(component.output for component in components)


MCT = TypeVar("MCT", bound="ModelComponent")


def convert_multiindex_coords(coords: dict):
    result = {}

    for k, v in coords.items():
        if isinstance(v, pd.MultiIndex):
            result[k] = np.arange(len(v))
        elif isinstance(v, xr.DataArray):
            if isinstance(next(iter(v.indexes.values())), pd.MultiIndex):
                result[k] = np.arange(len(v))
            else:
                result[k] = v
        else:
            result[k] = v
    return result


class ModelComponent(ABC):
    component_name: str
    _component_registry: dict = {}
    _name: str
    _model: pm.Model | None = None

    @classmethod
    def __init_subclass__(cls):
        """Register ModelComponents by name, for lookup by model config."""
        ModelComponent._component_registry[cls.component_name] = cls

    @abstractmethod
    def build(self, *args, **kwargs) -> None:
        """Construct a (sub)model for the component.

        This should set the values of `self.model`.

        If called within another `with pm.Model` context, the model
        will be a sub-model of the parent model. Variables and data in submodels
        (including those generated by `ModelComponent`) are propagated to the parent
        model.

        This mechanism allows PyMC to check if the components (sub-models) are consistent
        with the parent model.
        """
        if self._model is None:
            self.instantiate_model()

    @property
    def name(self) -> str:
        return self._name

    @name.setter
    def name(self, name: str) -> None:
        self._name = name

    @property
    def model(self) -> pm.Model:
        if self._model is None:
            raise AttributeError("model for this component has not been built yet.")
        return self._model

    @model.setter
    def model(self, model_: pm.Model) -> None:
        self._model = model_

    def __getitem__(self, name: str, /) -> Any:
        """Access model variables directly from ModelComponent."""
        if self.model is None:
            raise AttributeError(f"Cannot access variable {name}; this component has not been built yet.")
        return self.model[f"{self.name}::{name}"]

    def get(self, name: str, default: Any = None) -> Any:
        try:
            result = self[name]
        except KeyError:
            result = default
        return result

    def instantiate_model(self):
        if isinstance(self, HasCoords):
            coords = convert_multiindex_coords(self.coords())
            self.model = pm.Model(name=self.name, coords=coords)
        else:
            self.model = pm.Model(name=self.name)


class Default(ModelComponent):
    """Component that just builds its child components."""

    component_name = "default"

    def __init__(self, name: str, *child_components: ModelComponent) -> None:
        # NOTE: we can't use `children` in place of `child_components` because it will create an error during parsing
        # TODO: fix this problem ^^^
        super().__init__()
        self.name = name
        self.child_components = child_components

    def build(self) -> None:
        super().build()

        with self.model:
            for child in self.child_components:
                if hasattr(child, "inputs") and child.inputs:  # type: ignore ...we just checked that this attribute exists
                    inputs = child.inputs  # type: ignore ...we just checked that this attribute exists
                    child.build(*inputs)
                else:
                    try:
                        child.build()
                    except TypeError as e:
                        # TODO: print args from child.build
                        input_args = inspect.signature(child.build).parameters.keys()
                        raise ValueError(
                            f"Model component {child.name} requires inputs {', '.join(input_args)}"
                        ) from e


class LinearForwardComponent(ModelComponent):
    """Linear Component of forward model.

    Given a "H" matrix and a prior distribution, LinearForwardComponent.build()
    creates a random variable "x" with the given prior and outputs a deterministic
    quantity mu = H * x.

    The name of the component will be prepended to any variables in this model, so these
    variables can be accessed by names: `<name>::x` and `<name>::mu`.
    """

    component_name = "linear_forward_component"

    # TODO: component registry and staticmethod to sum up components
    # this method should check that output coords are aligned...
    def __init__(
        self,
        name: str,
        h_matrix: xr.DataArray | np.ndarray,
        prior: PriorArgs,
        input_dim: str | None = None,
        input_coord: xr.DataArray | np.ndarray | None = None,
        output_dim: str = "nmeasure",
        output_coord: xr.DataArray | np.ndarray | None = None,
    ) -> None:
        """Create LinearForwardComponent object.

        Args:
            name: name of this component.
            h_matrix: matrix mapping (unobserved) inputs to (observed) outputs.
            prior_args: PriorArgs to specify prior for input variable
            input_dims: coordinates to use for input variable. Default coordinates are integers starting at 0.
            output_dim: name of output dimension; default is "nmeasure"
            output_dims: coordinates to use for output variable. Default coordinates are integers starting at 0.

        Returns:
            None.
        """
        super().__init__()
        self.name = (
            name  # TODO: add class level code to make names automatically/fix name conflicts, e.g. counter
        )

        if isinstance(h_matrix, xr.DataArray):
            output_dim, input_dim = map(str, h_matrix.dims)
            input_coord = h_matrix.coords[input_dim]
            output_coord = h_matrix.coords[output_dim]
            h_matrix = h_matrix.values

        self.h_matrix = h_matrix
        self.h_matrix_values = h_matrix if isinstance(h_matrix, np.ndarray) else h_matrix.values

        self.input_dim = input_dim or f"nx_{self.name}"
        self.output_dim = output_dim

        # TODO: if h_matrix is DataArray, use its coordinates?
        input_coord = input_coord if input_coord is not None else np.arange(self.h_matrix_values.shape[1])

        if len(input_coord) != self.h_matrix_values.shape[1]:
            raise ValueError(
                f"Length of specified input coordinates is not equal to the number of rows of the given H matrix."
            )

        self.input_coords = {self.input_dim: input_coord}

        output_coord = output_coord if output_coord is not None else np.arange(self.h_matrix_values.shape[0])

        if len(output_coord) != self.h_matrix_values.shape[0]:
            raise ValueError(
                f"Length of specified output coordinates is not equal to the number of columns of the H matrix for {name}."
            )

        self.output_coords = {self.output_dim: output_coord}

        self.prior = prior

    def coords(self) -> dict:
        return {**self.input_coords, **self.output_coords}

    def build(self) -> None:
        super().build()

        with self.model:
            x = parse_prior("x", self.prior, dims=self.input_dim)
            hx = pm.Data("h", self.h_matrix, dims=(self.output_dim, self.input_dim))
            pm.Deterministic("mu", pt.dot(hx, x), dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["mu"]


class Flux(LinearForwardComponent):
    component_name = "flux"


class Tracer(ModelComponent):
    component_name = "tracer"

    def __init__(
        self,
        name: str,
        h_matrix: xr.DataArray | np.ndarray,
        prior: PriorArgs,
        inputs: list[Flux],
        flux_ratio: float = 1.0,
        output_dim: str = "nmeasure",
        output_coord: xr.DataArray | np.ndarray | None = None,
    ) -> None:
        super().__init__()
        self.name = name

        self.inputs = inputs

        if isinstance(h_matrix, xr.DataArray):
            output_dim, _ = map(str, h_matrix.dims)
            output_coord = h_matrix.coords[output_dim]
            h_matrix = h_matrix.values

        self.h_matrix = h_matrix

        self.output_dim = output_dim
        self.output_coord = output_coord if output_coord is not None else np.arange(self.h_matrix.shape[0])

        if len(self.output_coord) != self.h_matrix.shape[0]:
            raise ValueError(
                f"Length of specified output coordinates is not equal to the number of columns of the H matrix for {name}."
            )

        self.prior = prior

        self.flux_ratio = flux_ratio

    def coords(self) -> dict:
        return {self.output_dim: self.output_coord}

    def build(self, flux: Flux) -> None:
        super().build()  # instantiate model

        with self.model:
            x = flux.model["x"]
            input_dim = flux.input_dim

            r = parse_prior("r", self.prior)

            hx = pm.Data("h", self.h_matrix, dims=(self.output_dim, input_dim))
            pm.Deterministic("mu", pt.dot(hx, self.flux_ratio * r * x), dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["mu"]


class MultisectorFlux(ModelComponent):
    component_name = "multisector_flux"

    def __init__(self, name: str, *fluxes: Flux | Tracer) -> None:
        super().__init__()
        self.name = name

        # components
        self.child_components = fluxes

    def __getattr__(self, name: str) -> Any:
        if name != "inputs":
            for child in self.child_components:
                try:
                    return getattr(child, name)
                except AttributeError:
                    continue
        raise AttributeError(
            f"Attribute {name} not found in ForwardModel {self.name} or its child components."
        )

    def build(self) -> None:
        super().build()

        with self.model:
            for child in self.child_components:
                if hasattr(child, "inputs") and child.inputs:  # type: ignore ...we just checked that this attribute exists
                    inputs = child.inputs  # type: ignore ...we just checked that this attribute exists
                    child.build(*inputs)
                else:
                    try:
                        child.build()
                    except TypeError as e:
                        # TODO: print args from child.build
                        input_args = inspect.signature(child.build).parameters.keys()
                        raise ValueError(
                            f"Model component {child.name} requires inputs {', '.join(input_args)}"
                        ) from e

                # print(child.name, type(child))
                # if isinstance(child, Tracer):
                #     inputs = child.inputs
                #     child.build(*inputs)
                # else:
                #     child.build()

            pm.Deterministic("mu", sum_outputs(self.child_components), dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["mu"]


class BoundaryConditions(LinearForwardComponent):
    component_name = "bc"


class Offset(ModelComponent):
    component_name = "offset"

    def __init__(
        self,
        site_indicator: np.ndarray,
        prior: PriorArgs,
        output_dim: str = "nmeasure",
        name: str | None = None,
    ) -> None:
        super().__init__()

        if name is not None:
            self.name = f"{name}_offset"
        else:
            self.name = "offset"

        self.site_indicator = site_indicator
        self.offset_matrix = pd.get_dummies(site_indicator, drop_first=True, dtype=int).values

        self.input_dim = "offset_site_number"

        if len(uniq := np.unique(self.site_indicator)) < 2:
            raise ValueError("Cannot add offset for inversion with less than 2 sites.")
        else:
            self.input_coord = uniq[1:]

        self.output_dim = output_dim

        self.prior_args = prior

    def coords(self) -> dict:
        result = {
            self.output_dim: np.arange(len(self.site_indicator)),
            self.input_dim: self.input_coord,
        }
        return result

    def build(self) -> None:
        super().build()

        with self.model:
            x = parse_prior("x", self.prior_args, dims=self.input_dim)
            hx = pm.Data("h", self.offset_matrix, dims=(self.output_dim, self.input_dim))
            pm.Deterministic("mu", pt.dot(hx, x), dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["mu"]


class Baseline(ModelComponent):
    component_name = "baseline"

    def __init__(
        self, name: str = "baseline", bc: BoundaryConditions | None = None, offset: Offset | None = None
    ) -> None:
        super().__init__()
        self.name = name

        # components
        self.child_components = []

        if bc is not None:
            self.child_components.append(bc)

        if offset is not None:
            self.child_components.append(offset)

    def __bool__(self) -> bool:
        return bool(self.child_components)

    def __getattr__(self, name: str) -> Any:
        if name != "inputs":
            for child in self.child_components:
                try:
                    return getattr(child, name)
                except AttributeError:
                    continue
        raise AttributeError(f"Attribute {name} not found in Baseline {self.name} or its child components.")

    def build(self) -> None:
        super().build()

        with self.model:
            for child in self.child_components:
                child.build()

            if self.child_components:
                pm.Deterministic("mu", sum_outputs(self.child_components), dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["mu"]


class ForwardModel(ModelComponent):
    component_name = "forward_model"

    def __init__(
        self, name: str, flux: Flux | MultisectorFlux | Tracer, baseline: Baseline | None = None
    ) -> None:
        super().__init__()
        self.name = name

        # components
        self.child_components = []
        self.child_components.append(flux)  # empty list followed by append is to trick mypy...

        if (
            baseline is not None and bool(baseline) is not False
        ):  # shouldn't need explicit call to `bool` but it fails otherwise...
            self.child_components.append(baseline)

    def __getattr__(self, name: str) -> Any:
        if name != "inputs":
            for child in self.child_components:
                try:
                    return getattr(child, name)
                except AttributeError:
                    continue
        raise AttributeError(
            f"Attribute {name} not found in ForwardModel {self.name} or its child components."
        )

    def build(self) -> None:
        super().build()

        with self.model:
            for child in self.child_components:
                if isinstance(child, Tracer):
                    inputs = child.inputs
                    child.build(*inputs)
                else:
                    child.build()

            pm.Deterministic("mu", sum_outputs(self.child_components), dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["mu"]

    @property
    def flux_output(self) -> TensorVariable:
        return self.child_components[0].model["mu"]

    @property
    def baseline_output(self) -> TensorVariable | None:
        try:
            return self.child_components[1].model["mu"]
        except IndexError:
            return None


class Sigma(ModelComponent):
    """Minimal component for setting up sigma prior in likelihoods."""

    component_name = "sigma"

    def __init__(
        self,
        prior: PriorArgs,
        site_indicator: np.ndarray | xr.DataArray,
        freq: str | None = None,
        y_time: np.ndarray | None = None,
        per_site: bool = True,
        output_dim: str = "nmeasure",
        output_coord: np.ndarray | None = None,
        coord_prefix: str | None = None,
    ) -> None:
        super().__init__()

        self.prior = prior

        if isinstance(site_indicator, xr.DataArray):
            y_time = site_indicator.time.values
            output_dim = str(site_indicator.dims[0])
            output_coord = site_indicator.coords[output_dim]
            site_indicator = site_indicator.values

        if freq is not None:
            if y_time is None:
                raise ValueError("If `freq` is not None, then `y_time` must be provided.")
            freq_index = sigma_freq_indicies(y_time, freq)
        else:
            freq_index = np.zeros_like(site_indicator, dtype=int)

        self.site_indicator = site_indicator
        self.freq_index = freq_index
        self.per_site = per_site

        if self.per_site:
            self.sites = self.site_indicator.astype(int)
        else:
            self.sites = np.zeros_like(self.site_indicator).astype(int)

        self.output_dim = output_dim

        self.output_coord = output_coord if output_coord is not None else np.arange(len(self.site_indicator))

        self._coord_prefix = coord_prefix

        if self._coord_prefix is not None:
            self.sig_dims = ("nsigma_site", "nsigma_time")
        else:
            self.sig_dims = (f"{self._coord_prefix}_nsigma_site", f"{self._coord_prefix}_nsigma_time")

    def coords(self) -> dict:
        result = {
            self.output_dim: self.output_coord,
            self.sig_dims[0]: np.unique(self.site_indicator) if self.per_site else [0],
            self.sig_dims[1]: np.unique(self.freq_index),
        }
        return result

    def instantiate_model(self) -> None:
        self.model = pm.modelcontext(None)

        with self.model as model:
            model.add_coords(
                convert_multiindex_coords(self.coords())
            )  # add coordinates here so that they are added to existing model context

    def build(self) -> None:
        """This is a bit of a hack to build this component inside of another component without
        creating a long name.

        See usage in `RHIMELikelihood`.
        """
        super().build()

        with self.model:
            sigma = parse_prior("sigma", self.prior, dims=self.sig_dims)
            pm.Deterministic("sigma_obs_aligned", sigma[self.sites, self.freq_index], dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["sigma_obs_aligned"]


class RHIMELikelihood(ModelComponent):
    """Likelihood for RHIME model."""

    component_name = "rhime_likelihood"

    def __init__(
        self,
        y_obs: np.ndarray,
        error: np.ndarray,
        sigma: Sigma,
        inputs: Iterable[ModelComponent],
        min_error: np.ndarray | float = 0.0,
        pollution_events_from_obs: bool = True,
        no_model_error: bool = False,
        name: str = "likelihood",
        output_dim: str = "nmeasure,",
    ) -> None:
        super().__init__()
        self.name = name
        self.inputs = list(inputs)

        self.y_obs = y_obs
        self.error = error

        self.sigma = sigma

        if isinstance(min_error, float) or (isinstance(min_error, np.ndarray) and min_error.ndim == 0):
            self.min_error = min_error * np.ones_like(y_obs)
        else:
            self.min_error = min_error

        self.pollution_events_from_obs = pollution_events_from_obs
        self.no_model_error = no_model_error

        self.output_dim = output_dim

    def coords(self) -> dict:
        return {self.output_dim: np.arange(len(self.y_obs))}

    def build(self, forward: ForwardModel) -> None:
        super().build()

        with self.model:
            y_obs = pm.Data("y_obs", self.y_obs, dims=self.output_dim)
            error = pm.Data("error", self.error, dims=self.output_dim)
            min_error = pm.Data("min_error", self.min_error, dims=self.output_dim)

            baseline = forward.baseline_output

            mu_flux = forward.flux_output

            if self.pollution_events_from_obs is True:
                if baseline is not None:
                    pollution_event = pt.abs(y_obs - baseline)
                else:
                    pollution_event = pt.abs(y_obs) + 1e-6 * pt.mean(
                        y_obs
                    )  # small non-zero term to prevent NaNs
            else:
                pollution_event = pt.abs(mu_flux)

            self.sigma.build()
            pollution_event_scaled_error = pollution_event * self.sigma.output

            if self.no_model_error is True:
                # need some small non-zero value to avoid sampling problems
                mean_obs = pt.mean(y_obs)
                small_amount = 1e-12 * mean_obs
                eps = pt.maximum(pt.abs(error), small_amount)  # type: ignore
            else:
                eps = pt.maximum(pt.sqrt(error**2 + pollution_event_scaled_error**2), min_error)  # type: ignore

            epsilon = pm.Deterministic("epsilon", eps, dims=self.output_dim)

            mu = forward.output

            pm.Normal("y", mu=mu, sigma=epsilon, observed=y_obs, dims=self.output_dim)


class GaussianLikelihood(ModelComponent):
    """Likelihood for RHIME model."""

    component_name = "gaussian_likelihood"

    def __init__(
        self,
        y_obs: np.ndarray | xr.DataArray,
        error: np.ndarray | xr.DataArray,
        sigma: Sigma,
        inputs: Iterable[ModelComponent],
        name: str = "likelihood",
        output_dim: str = "nmeasure",
        output_coord: np.ndarray | None = None,
    ) -> None:
        super().__init__()
        self.name = name
        self.inputs = list(inputs)

        if isinstance(y_obs, xr.DataArray):
            output_dim = str(y_obs.dims[0])
            output_coord = y_obs.coords[output_dim]
            y_obs = y_obs.values

        if isinstance(error, xr.DataArray):
            error = error.values

        self.y_obs = y_obs
        self.error = error

        self.sigma = sigma

        self.output_dim = output_dim
        self.output_coord = output_coord if output_coord is not None else np.arange(len(self.y_obs))

    def coords(self) -> dict:
        return {self.output_dim: self.output_coord}

    def build(self, forward: ForwardModel) -> None:
        super().build()

        with self.model:
            y_obs = pm.Data("y_obs", self.y_obs, dims=self.output_dim)
            error = pm.Data("error", self.error, dims=self.output_dim)

            self.sigma.build()

            epsilon = pm.Deterministic(
                "epsilon", pt.sqrt(error**2 + self.sigma.output**2), dims=self.output_dim
            )
            mu = forward.output

            pm.Normal("y", mu=mu, sigma=epsilon, observed=y_obs, dims=self.output_dim)
