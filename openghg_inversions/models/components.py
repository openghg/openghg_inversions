from __future__ import annotations

from abc import ABC, abstractmethod
import inspect
from typing import Any, Iterable, Protocol, TypeVar

import numpy as np
import pandas as pd
import pymc as pm
import pytensor.tensor as pt
from pytensor.tensor.variable import TensorVariable
import xarray as xr

from openghg_inversions.models.priors import parse_prior, PriorArgs
from openghg_inversions.models.setup import sigma_freq_indicies


def sum_outputs(components: Iterable[HasOutput]) -> TensorVariable:
    """Sum the output variables of a list of components."""
    return sum(component.output for component in components)


MCT = TypeVar("MCT", bound="ModelComponent")


class ModelComponent(ABC):
    component_name: str
    _component_registry: dict = {}
    _name: str
    _model: pm.Model | None = None

    @classmethod
    def __init_subclass__(cls):
        """Register ModelComponents by name, for lookup by model config."""
        ModelComponent._component_registry[cls.component_name] = cls

    @abstractmethod
    def build(self, *args, **kwargs) -> None:
        """Construct a (sub)model for the component.

        This should set the values of `self.model`.

        If called within another `with pm.Model` context, the model
        will be a sub-model of the parent model. Variables and data in submodels
        (including those generated by `ModelComponent`) are propagated to the parent
        model.

        This mechanism allows PyMC to check if the components (sub-models) are consistent
        with the parent model.
        """
        pass

    @property
    def name(self) -> str:
        return self._name

    @name.setter
    def name(self, name: str) -> None:
        self._name = name

    @property
    def model(self) -> pm.Model:
        if self._model is None:
            raise AttributeError("model for this component has not been built yet.")
        return self._model

    @model.setter
    def model(self, model_: pm.Model) -> None:
        self._model = model_

    def __getitem__(self, name: str, /) -> Any:
        """Access model variables directly from ModelComponent."""
        if self.model is None:
            raise AttributeError(f"Cannot access variable {name}; this component has not been built yet.")
        return self.model[f"{self.name}::{name}"]

    def get(self, name: str, default: Any = None) -> Any:
        try:
            result = self[name]
        except KeyError:
            result = default
        return result


class HasOutput(Protocol):
    @property
    @abstractmethod
    def output(self) -> TensorVariable: ...


class Default(ModelComponent):
    """Component that just builds its child components."""
    component_name = "default"

    def __init__(self, name: str, *child_components: ModelComponent) -> None:
        # NOTE: we can't use `children` in place of `child_components` because it will create an error during parsing
        # TODO: fix this problem ^^^
        super().__init__()
        self.name = name
        self.child_components = child_components

    def build(self) -> None:
        self.model = pm.Model(name=self.name)

        with self.model:
            for child in self.child_components:
                if hasattr(child, "inputs") and child.inputs: # type: ignore ...we just checked that this attribute exists
                    inputs = child.inputs  # type: ignore ...we just checked that this attribute exists
                    child.build(*inputs)
                else:
                    try:
                        child.build()
                    except TypeError as e:
                        # TODO: print args from child.build
                        input_args = inspect.signature(child.build).parameters.keys()
                        raise ValueError(f"Model component {child.name} requires inputs {', '.join(input_args)}") from e


class LinearForwardComponent(ModelComponent):
    """Linear Component of forward model.

    Given a "H" matrix and a prior distribution, LinearForwardComponent.build()
    creates a random variable "x" with the given prior and outputs a deterministic
    quantity mu = H * x.

    The name of the component will be prepended to any variables in this model, so these
    variables can be accessed by names: `<name>::x` and `<name>::mu`.
    """

    component_name = "linear_forward_component"

    # TODO: component registry and staticmethod to sum up components
    # this method should check that output coords are aligned...
    def __init__(
        self,
        name: str,
        h_matrix: xr.DataArray | np.ndarray,
        prior: PriorArgs,
        input_coords: xr.DataArray | np.ndarray | None = None,
        output_dim: str = "nmeasure",
        output_coords: xr.DataArray | np.ndarray | None = None,
    ) -> None:
        """Create LinearForwardComponent object.

        Args:
            name: name of this component.
            h_matrix: matrix mapping (unobserved) inputs to (observed) outputs.
            prior_args: PriorArgs to specify prior for input variable
            input_dims: coordinates to use for input variable. Default coordinates are integers starting at 0.
            output_dim: name of output dimension; default is "nmeasure"
            output_dims: coordinates to use for output variable. Default coordinates are integers starting at 0.

        Returns:
            None.
        """
        super().__init__()
        self.name = (
            name  # TODO: add class level code to make names automatically/fix name conflicts, e.g. counter
        )

        self.h_matrix = h_matrix
        self.h_matrix_values = h_matrix if isinstance(h_matrix, np.ndarray) else h_matrix.values

        self.input_dim = f"nx_{self.name}"
        self.output_dim = output_dim

        # TODO: if h_matrix is DataArray, use its coordinates?
        input_coords = input_coords or np.arange(self.h_matrix_values.shape[1])

        if len(input_coords) != self.h_matrix_values.shape[1]:
            raise ValueError(
                f"Length of specified input coordinates is not equal to the number of rows of the given H matrix."
            )

        self.input_coords = {self.input_dim: input_coords}

        output_coords = output_coords or np.arange(self.h_matrix_values.shape[0])

        if len(output_coords) != self.h_matrix_values.shape[0]:
            raise ValueError(
                f"Length of specified output coordinates is not equal to the number of columns of the given H matrix."
            )

        self.output_coords = {self.output_dim: output_coords}

        self.prior = prior

    def coords(self) -> dict:
        return {**self.input_coords, **self.output_coords}

    def build(self) -> None:
        self.model = pm.Model(
            name=self.name, coords=self.coords()
        )  # name used to distinguish variables created by this component

        with self.model:
            x = parse_prior("x", self.prior, dims=self.input_dim)
            hx = pm.Data("h", self.h_matrix, dims=(self.output_dim, self.input_dim))
            pm.Deterministic("mu", pt.dot(hx, x), dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["mu"]


class Flux(LinearForwardComponent):
    component_name = "flux"


class Tracer(ModelComponent):
    component_name = "tracer"

    def __init__(
        self,
        name: str,
        h_matrix: xr.DataArray | np.ndarray,
        prior: PriorArgs,
        inputs: list[Flux],
        input_coords: xr.DataArray | np.ndarray | None = None,
        output_dim: str = "nmeasure",
        output_coords: xr.DataArray | np.ndarray | None = None,
    ) -> None:
        super().__init__()
        self.name = name

        self.inputs = inputs

        self.h_matrix = h_matrix
        self.h_matrix_values = h_matrix if isinstance(h_matrix, np.ndarray) else h_matrix.values

        self.output_dim = output_dim
        output_coords = output_coords or np.arange(self.h_matrix_values.shape[0])

        if len(output_coords) != self.h_matrix_values.shape[0]:
            raise ValueError(
                f"Length of specified output coordinates is not equal to the number of columns of the given H matrix."
            )

        self.output_coords = {self.output_dim: output_coords}

        self.prior = prior

    def coords(self) -> dict:
        return self.output_coords


    def build(self, flux: Flux) -> None:
        self.model = pm.Model(
            name=self.name,
            coords=self.coords()
        )  # name used to distinguish variables created by this component

        with self.model:
            x = flux.model["x"]
            input_dim = flux.model.named_vars_to_dims[x.name][0]

            r = parse_prior("r", self.prior)

            hx = pm.Data("h", self.h_matrix, dims=(self.output_dim, input_dim))
            pm.Deterministic("mu", pt.dot(hx, r * x), dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["mu"]



class MultisectorFlux(ModelComponent):
    component_name = "multisector_flux"

    def __init__(self, name: str, *fluxes: Flux | Tracer) -> None:
        super().__init__()
        self.name = name

        # components
        self.child_components = fluxes

    def __getattr__(self, name: str) -> Any:
        if name != "inputs":
            for child in self.child_components:
                try:
                    return getattr(child, name)
                except AttributeError:
                    continue
        raise AttributeError(
            f"Attribute {name} not found in ForwardModel {self.name} or its child components."
        )

    def build(self) -> None:
        self.model = pm.Model(name=self._name)

        with self.model:
            for child in self.child_components:
                if hasattr(child, "inputs") and child.inputs: # type: ignore ...we just checked that this attribute exists
                    inputs = child.inputs  # type: ignore ...we just checked that this attribute exists
                    child.build(*inputs)
                else:
                    try:
                        child.build()
                    except TypeError as e:
                        # TODO: print args from child.build
                        input_args = inspect.signature(child.build).parameters.keys()
                        raise ValueError(f"Model component {child.name} requires inputs {', '.join(input_args)}") from e

                # print(child.name, type(child))
                # if isinstance(child, Tracer):
                #     inputs = child.inputs
                #     child.build(*inputs)
                # else:
                #     child.build()

            pm.Deterministic("mu", sum_outputs(self.child_components), dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["mu"]


class BoundaryConditions(LinearForwardComponent):
    component_name = "bc"


class Offset(ModelComponent):
    component_name = "offset"

    def __init__(
        self,
        site_indicator: np.ndarray,
        prior: PriorArgs,
        output_dim: str = "nmeasure",
        name: str | None = None,
    ) -> None:
        super().__init__()

        if name is not None:
            self.name = f"{name}_offset"
        else:
            self.name = "offset"

        self.site_indicator = site_indicator
        self.offset_matrix = pd.get_dummies(site_indicator, drop_first=True, dtype=int).values

        self.input_dim = "offset_site_number"

        if len(uniq := np.unique(self.site_indicator)) < 2:
            raise ValueError("Cannot add offset for inversion with less than 2 sites.")
        else:
            self.input_coord = uniq[1:]

        self.output_dim = output_dim

        self.prior_args = prior

    def coords(self) -> dict:
        result = {
            self.output_dim: np.arange(len(self.site_indicator)),
            self.input_dim: self.input_coord,
        }
        return result

    def build(self) -> None:
        self.model = pm.Model(
            name=self.name, coords=self.coords()
        )  # name used to distinguish variables created by this component

        with self.model:
            x = parse_prior("x", self.prior_args, dims=self.input_dim)
            hx = pm.Data("h", self.offset_matrix, dims=(self.output_dim, self.input_dim))
            pm.Deterministic("mu", pt.dot(hx, x), dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["mu"]


class Baseline(ModelComponent):
    component_name = "baseline"

    def __init__(self, name: str = "baseline", bc: BoundaryConditions | None = None, offset: Offset | None = None) -> None:
        super().__init__()
        self.name = name

        # components
        self.child_components = []

        if bc is not None:
            self.child_components.append(bc)

        if offset is not None:
            self.child_components.append(offset)

    def __bool__(self) -> bool:
        return bool(self.child_components)

    def __getattr__(self, name: str) -> Any:
        if name != "inputs":
            for child in self.child_components:
                try:
                    return getattr(child, name)
                except AttributeError:
                    continue
        raise AttributeError(f"Attribute {name} not found in Baseline {self.name} or its child components.")

    def build(self) -> None:
        self.model = pm.Model(name=self._name)

        with self.model:
            for child in self.child_components:
                child.build()

            if self.child_components:
                pm.Deterministic("mu", sum_outputs(self.child_components), dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["mu"]


class ForwardModel(ModelComponent):
    component_name = "forward_model"

    def __init__(self, name: str, flux: Flux | MultisectorFlux | Tracer, baseline: Baseline | None = None) -> None:
        super().__init__()
        self.name = name

        # components
        self.child_components = []
        self.child_components.append(flux)  # empty list followed by append is to trick mypy...

        if baseline is not None and bool(baseline) is not False:  # shouldn't need explicit call to `bool` but it fails otherwise...
            self.child_components.append(baseline)

    def __getattr__(self, name: str) -> Any:
        if name != "inputs":
            for child in self.child_components:
                try:
                    return getattr(child, name)
                except AttributeError:
                    continue
        raise AttributeError(
            f"Attribute {name} not found in ForwardModel {self.name} or its child components."
        )

    def build(self) -> None:
        self.model = pm.Model(name=self._name)

        with self.model:
            for child in self.child_components:
                if isinstance(child, Tracer):
                    inputs = child.inputs
                    child.build(*inputs)
                else:
                    child.build()

            pm.Deterministic("mu", sum_outputs(self.child_components), dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["mu"]

    @property
    def flux_output(self) -> TensorVariable:
        return self.child_components[0].model["mu"]

    @property
    def baseline_output(self) -> TensorVariable | None:
        try:
            return self.child_components[1].model["mu"]
        except IndexError:
            return None



class Sigma(ModelComponent):
    """Minimal component for setting up sigma prior in likelihoods."""

    component_name = "sigma"

    def __init__(
        self,
        prior: PriorArgs,
        site_indicator: np.ndarray,
        freq: str | None = None,
        y_time: np.ndarray | None = None,
        per_site: bool = True,
        sites: list[str] | None = None,
        output_dim: str = "nmeasure"
    ) -> None:
        super().__init__()

        self.prior = prior

        if freq is not None:
            if y_time is None:
                raise ValueError("If `freq` is not None, then `y_time` must be provided.")
            freq_index = sigma_freq_indicies(y_time, freq)
        else:
            freq_index = np.zeros_like(site_indicator, dtype=int)

        self.site_indicator = site_indicator
        self.freq_index = freq_index
        self.per_site = per_site

        self.sites = sites

        self.output_dim = output_dim

    def coords(self) -> dict:
        result = {
            self.output_dim: np.arange(len(self.site_indicator)),
            "sites": self.sites if self.sites is not None else np.unique(self.site_indicator),
            "nsigma_time": np.unique(self.freq_index),
            "nsigma_site": np.unique(self.site_indicator) if self.per_site else [0],
        }
        return result

    def build(self) -> None:
        """This is a bit of a hack to build this component inside of another component without
        creating a long name.

        See usage in `RHIMELikelihood`.
        """
        self.model = pm.modelcontext(None)

        with self.model as model:

            model.add_coords(self.coords())

            sigma = parse_prior("sigma", self.prior, dims=("nsigma_site", "nsigma_time"))

            # convert siteindicator into a site indexer
            # TODO: use self.sites here?
            if self.per_site:
                sites = self.site_indicator.astype(int)
            else:
                sites = np.zeros_like(self.site_indicator).astype(int)

            pm.Deterministic("sigma_obs_aligned", sigma[sites, self.freq_index], dims=self.output_dim)

    @property
    def output(self) -> TensorVariable:
        return self.model["sigma_obs_aligned"]


class RHIMELikelihood(ModelComponent):
    """Likelihood for RHIME model."""

    component_name = "rhime_likelihood"

    def __init__(
        self,
        y_obs: np.ndarray,
        error: np.ndarray,
        sigma: Sigma,
        inputs: Iterable[ModelComponent],
        min_error: np.ndarray | float = 0.0,
        pollution_events_from_obs: bool = True,
        no_model_error: bool = False,
        name: str = "likelihood",
        output_dim: str = "nmeasure,"
    ) -> None:
        super().__init__()
        self.name = name
        self.inputs = list(inputs)

        self.y_obs = y_obs
        self.error = error

        self.sigma = sigma

        if isinstance(min_error, float) or (isinstance(min_error, np.ndarray) and min_error.ndim == 0):
            self.min_error = min_error * np.ones_like(y_obs)
        else:
            self.min_error = min_error

        self.pollution_events_from_obs = pollution_events_from_obs
        self.no_model_error = no_model_error

        self.output_dim = output_dim

    def coords(self) -> dict:
        return {self.output_dim: np.arange(len(self.y_obs))}

    def build(self, forward: ForwardModel) -> None:
        self.model = pm.Model(name=self.name, coords=self.coords())

        with self.model:
            y_obs = pm.Data("y_obs", self.y_obs, dims=self.output_dim)
            error = pm.Data("error", self.error, dims=self.output_dim)
            min_error = pm.Data("min_error", self.min_error, dims=self.output_dim)

            baseline = forward.baseline_output

            mu_flux = forward.flux_output

            if self.pollution_events_from_obs is True:
                if baseline is not None:
                    pollution_event = pt.abs(y_obs - baseline)
                else:
                    pollution_event = pt.abs(y_obs) + 1e-6 * pt.mean(
                        y_obs
                    )  # small non-zero term to prevent NaNs
            else:
                pollution_event = pt.abs(mu_flux)

            self.sigma.build()
            pollution_event_scaled_error = pollution_event * self.sigma.output

            if self.no_model_error is True:
                # need some small non-zero value to avoid sampling problems
                mean_obs = pt.mean(y_obs)
                small_amount = 1e-12 * mean_obs
                eps = pt.maximum(pt.abs(error), small_amount)  # type: ignore
            else:
                eps = pt.maximum(pt.sqrt(error**2 + pollution_event_scaled_error**2), min_error)  # type: ignore

            epsilon = pm.Deterministic("epsilon", eps, dims=self.output_dim)

            mu = forward.output

            pm.Normal("y", mu=mu, sigma=epsilon, observed=y_obs, dims=self.output_dim)
